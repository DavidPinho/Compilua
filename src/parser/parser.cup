import java_cup.runtime.*;
import tree.*;
import tree.Number;


/* Terminals (tokens returned by lexer). */

terminal      SEMICOLON, ASSIGN_OP, DO_KWORD, END_KWORD, FOR_KWORD, WHILE;
terminal      IF_KWORD, THEN_KWORD;
terminal      ELSE_KWORD, COMA, VAR_KWORD;
terminal      DOT, COLON;
terminal      LBRACKET, RBRACKET;
terminal      LPAREN, RPAREN;
terminal      PLUS_OP, MINUS_OP, TIMES_OP, SLASH_OP, POT_OP, PERCENT_OP;
terminal      LESSEQUALS_OP, MOREEQUALS_OP, LESS_OP, MORE_OP, EQUALS_OP, DIFFERENT_OP;
terminal      AND_KWORD, OR_KWORD, NOT_KWORD, HASH_OP, MINUS_UNOP;

terminal 	  java.lang.Number NUMBER;
terminal 	  java.lang.String STRING;
terminal 	  java.lang.String IDENTIFIER;


/*NON TERMINALS */

non terminal  Bloco bloco;
non terminal  Comando comando;
non terminal  ifstat, elsestat;
non terminal  chamadadefuncao, args;
non terminal  Exp listaexp, listaexpaux;
non terminal  Exp exp;
non terminal  declaracaovariavel;


//--------------- Precedences---------------------------------------------- 

precedence left COMA;
precedence left OR_KWORD;
precedence left AND_KWORD;
precedence left LESS_OP, MORE_OP, LESSEQUALS_OP, MOREEQUALS_OP, DIFFERENT_OP, EQUALS_OP;
precedence left PLUS_OP,MINUS_OP;
precedence left TIMES_OP, SLASH_OP, PERCENT_OP;
precedence left NOT_KWORD, HASH_OP, PERCENT_OP, MINUS_UNOP;
precedence right POT_OP;
precedence left LPAREN, RPAREN;




//----------------The grammar---------------------------------------------------- 

start with bloco;


bloco 	    ::= bloco:b comando:c {: RESULT = new Bloco(b,c); :}
					| bloco:b comando:c SEMICOLON {: RESULT = new Bloco(b,c); :}
					|
					;

	
comando     ::=	IDENTIFIER:id ASSIGN_OP exp:e	 {: RESULT = new Comando(id, e);:}		       
					       | WHILE exp:e DO_KWORD bloco:b END_KWORD {: RESULT = new Comando(e,b); :}
					       | ifstat
				           | chamadadefuncao			
				           | declaracaovariavel                        
				           ;


ifstat 	        ::=   IF_KWORD exp THEN_KWORD bloco elsestat END_KWORD;

//esse n�o � necessario
elsestat        ::=   ELSE_KWORD bloco
					      |
					      ;


listaexp   ::=      listaexpaux  exp;

listaexpaux  ::=    listaexpaux exp COMA 
						|
						;
						


exp       ::=	     NUMBER:n1 {: RESULT = new Exp(n1);:}
					   |  IDENTIFIER:id {: RESULT =  new Exp(id); :}
					   |  chamadadefuncao
					   |  LPAREN exp RPAREN				
					   |  exp:exp1 PLUS_OP exp:exp2 {: RESULT =  new Exp(exp1,sym.PLUS_OP,exp2); :}
					   |  exp:exp1 MINUS_OP exp:exp2 {: RESULT =  new Exp(exp1,sym.MINUS_OP,exp2); :}
					   |  exp:exp1 TIMES_OP exp:exp2 {: RESULT =  new Exp(exp1,sym.TIMES_OP,exp2); :}
					   |  exp:exp1 SLASH_OP exp:exp2 {: RESULT =  new Exp(exp1,sym.SLASH_OP,exp2); :}
					   |  exp:exp1 LESS_OP exp:exp2 {: RESULT =  new Exp(exp1,sym.LESS_OP,exp2); :}
					   |  exp:exp1 LESSEQUALS_OP exp:exp2 {: RESULT =  new Exp(exp1,sym.LESSEQUALS_OP,exp2); :}
					   |  exp:exp1 MORE_OP exp:exp2 {: RESULT =  new Exp(exp1,sym.MORE_OP,exp2); :}
					   |  exp:exp1 MOREEQUALS_OP exp:exp2 {: RESULT =  new Exp(exp1,sym.MOREEQUALS_OP,exp2); :}
					   |  exp:exp1 EQUALS_OP exp:exp2 {: RESULT =  new Exp(exp1,sym.EQUALS_OP,exp2); :}
					   |  exp:exp1 DIFFERENT_OP exp:exp2 {: RESULT =  new Exp(exp1,sym.DIFFERENT_OP,exp2); :}
					   |  exp:exp1 AND_KWORD exp:exp2 {: RESULT =  new Exp(exp1,sym.AND_KWORD,exp2); :}		
					   |  exp:exp1 OR_KWORD exp:exp2 {: RESULT =  new Exp(exp1,sym.OR_KWORD,exp2); :}					   
					   |  MINUS_UNOP exp:exp1 {: RESULT = new Exp(sym.MINUS_UNOP,exp1);:}
					   |  NOT_KWORD exp:exp1 {: RESULT = new Exp(sym.NOT_KWORD,exp1);:}
					   ; 


chamadadefuncao ::=  	LPAREN exp:e RPAREN args
							| LPAREN exp:e RPAREN COLON IDENTIFIER args
							;


args   ::=    LPAREN RPAREN
					|  LPAREN listaexp RPAREN
					|  STRING
					;


declaracaovariavel ::= VAR_KWORD IDENTIFIER
						| VAR_KWORD IDENTIFIER ASSIGN_OP exp
						;